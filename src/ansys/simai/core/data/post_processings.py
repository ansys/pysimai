# Copyright (C) 2023 ANSYS, Inc. and/or its affiliates.
# SPDX-License-Identifier: MIT
#
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import logging
import numbers
import sys
from abc import ABC, abstractmethod
from inspect import cleandoc
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Type, Union

from ansys.simai.core.data.base import ComputableDataModel, Directory
from ansys.simai.core.data.downloads import DownloadableResult
from ansys.simai.core.errors import InvalidArguments, InvalidServerStateError
from ansys.simai.core.utils.numerical import convert_axis_and_coordinate_to_plane_eq_coeffs

if TYPE_CHECKING:
    from ansys.simai.core.data.predictions import Prediction


logger = logging.getLogger(__name__)


class PostProcessing(ComputableDataModel, ABC):
    """
    Local representation of a PostProcessing object.

    This is an abstract class, depending on the post-processing a different implementation
    will be returned, see `Available post-processings`_.
    """

    # NOTE for developers: New post-processings must be added to the root __init__.py file

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._results = None
        # Set by the Directory, or else on first access
        self._prediction = None

    @property
    def parameters(self) -> Optional[Dict[str, Any]]:
        """The parameters with which this post-processing was ran."""
        return self.fields["location"]

    @property
    def prediction_id(self) -> str:
        """
        The parent prediction's id.

        See Also:
            - :attr:`prediction`: Get the parent prediction
        """
        return self.fields["prediction_id"]

    @property
    def prediction(self) -> "Prediction":
        """
        The parent prediction.

        It will be queried if not already known by the current SDK session.

        See Also:
            - :attr:`prediction_id`: Return the parent prediction's id without query
        """
        if self._prediction is None:
            if self.prediction_id in self._client.predictions._registry:
                self._prediction = self._client.predictions._registry[self.prediction_id]
            else:
                self._prediction = self._client.predictions.get(id=self.prediction_id)
        return self._prediction

    @property
    def type(self) -> str:
        """The type of PostProcessing that this object represents."""
        return self._fields["type"]

    @property
    @abstractmethod
    def data(self):
        """
        Get the data generated by the post-processing.

        Return type may vary depending on the post-processing, it can be a ``dict``
        or if the data is binary it will be a :class:`DownloadableResult` which provides
        helpers to download the data into a file or into memory.
        """
        pass

    @classmethod
    def _api_name(cls) -> str:
        # The name of the post-processing in API calls. Override if different from the class name.
        return cls.__name__

    def _get_results(self, cache=True):
        """
        Internal method to retrieve the results of this post-processing.

        Args:
            cache
                True by default to save results to cache
                False for download links which expire,
                thus must be queried just before download.
        """
        if cache and self._results:
            return self._results
        res = self._client._api.get_post_processing_result(self.id)
        if cache:
            self._results = res
        return res

    def delete(self):
        """
        Delete the post-processing and its result data.

        Raises:
            NotFoundError: if the post-processing has already been deleted.
        """
        self._client._api.delete_post_processing(self.id)
        self._unregister()
        if self._prediction is not None:
            self._prediction._post_processings._delete_local_post_processing(self)


class ExportablePostProcessing(PostProcessing, ABC):
    def export(self, format: Optional[str] = "json") -> DownloadableResult:
        """
        Export the post-processing results in the desired format.

        Accessing this property will block until the data is ready.

        Args:
            format: format in which the data is to be exported:
                one of ``json``, ``csv.zip`` or ``xlsx``, defaults to ``json``.
                Please note that ``csv.zip`` exports a zip archive containing
                multiple csv sheets.

        Returns:
            A :class:`DownloadableResult` object allowing
            to download the exported data into a file
            or access it in memory.
        """
        self.wait()
        return DownloadableResult(
            self._client._api.post_processings_export_url(),
            self._client,
            request_method="POST",
            request_json_body={"ids": [self.id], "format": format},
        )


class GlobalCoefficients(ExportablePostProcessing):
    """
    Representation of the global coefficients of a prediction.

    The data attribute contains a dictionary representing the GlobalCoefficients
    with its pressure and velocity components.

    Generated through :meth:`PredictionPostProcessings.global_coefficients()`
    """

    @property
    def data(self) -> Dict[str, List]:
        """
        A dictionary containing the GlobalCoefficients including pressure
        and velocity components.

        Accessing this property will block until the data is ready.
        """
        self.wait()

        results = self._get_results()
        return results["data"]["values"]


class SurfaceEvol(ExportablePostProcessing):
    """
    Representation of the SurfaceEvol.

    Generated through :meth:`PredictionPostProcessings.surface_evol()`
    """

    @property
    def data(self) -> DownloadableResult:
        """
        A :class:`DownloadableResult` object allowing access to the
        SurfaceEvol json data both directly in memory or to download it into a file.

        Accessing this property will block until the data is ready.
        """
        self.wait()
        results = self._get_results(cache=False)
        return DownloadableResult(results["data"]["resources"]["json"], self._client)

    def as_dict(self) -> Dict[str, Any]:
        """
        Helper to download the SurfaceEvol json data and load it as python dictionary.

        Accessing this method will block until the data is ready.
        """
        return json.load(self.data.in_memory())


class Slice(PostProcessing):
    """
    Representation of a slice from the prediction, in PNG or VTP format.

    Generated through :meth:`PredictionPostProcessings.slice()`
    """

    @property
    def data(self) -> DownloadableResult:
        """
        A :class:`DownloadableResult` object allowing
        to access the slice data both directly in memory
        or to download it into a file.

        Accessing this property will block until the data is ready.

        Returns:
            A :class:`DownloadableResult`
        """
        self.wait()
        results = self._get_results(cache=False)
        print(self.fields)
        return DownloadableResult(
            results["data"]["resources"][self.parameters.get("output_format", "png")],
            self._client,
        )


class _PostProcessingVTKExport(PostProcessing, ABC):
    """
    Representation of the result of the prediction in a format of the VTK family.
    """

    @property
    def data(self) -> DownloadableResult:
        """
        A :class:`DownloadableResult` object allowing
        access to the VTK data either directly in memory
        or downloaded it into a file.

        Accessing this property will block until the data is ready.
        """
        self.wait()
        results = self._get_results(cache=False)
        return DownloadableResult(results["data"]["resources"]["vtk"], self._client)


class VolumeVTU(_PostProcessingVTKExport):
    """
    Export of the volume of the prediction in VTU format.

    Generated through :meth:`PredictionPostProcessings.volume_vtu()`
    """


class SurfaceVTP(_PostProcessingVTKExport):
    """
    Export of the surface of the prediction in VTP format.

    Generated through :meth:`~PredictionPostProcessings.surface_vtp()`
    """


class PredictionPostProcessings:
    """
    Class acting as namespace inside :py:class:`~ansys.simai.core.data.predictions.Prediction` objects.

    Allows to analyse the results of a prediction.

    It can be accessed from any prediction object through its
    :attr:`~ansys.simai.core.data.predictions.Prediction.post` property:

    Example:
        .. code-block:: python

            sim = simai.predictions.get("<prediction_id>")
            # Run the global coefficients
            coefs = sim.post.global_coefficients()
    """

    def __init__(self, prediction: "Prediction"):
        self._client = prediction._client
        self.prediction = prediction
        # _post_processings contains, for each Type,
        # a Dict of params -> postProcess
        self._post_processings: Dict[Type[PostProcessing], Dict[frozenset, PostProcessing]] = {}

    def global_coefficients(self, run: bool = True) -> Optional[GlobalCoefficients]:
        """
        Compute or get the global coefficients of the prediction.

        This is a non-blocking method. It will return the GlobalCoefficients
        object without waiting. This object may not have data right away
        if computation is still in progress. Data will be filled
        asynchronously once computation is finished.
        State of computation can be monitored with the is_ready flag,
        or waited upon with the wait() method.

        Computation will be launched only on first call of this method.
        Subsequent calls will not relaunch it.

        Args:
            run: When False, the post-processing will not be computed and None will be
                returned if it does not exist yet.

        Returns:
            A GlobalCoefficients object, that will eventually contain
            the global coefficients with its pressure and velocity components.
            `None` if `run` is `False` and the post-processing does not exist.
        """
        return self._get_or_run(GlobalCoefficients, {}, run)

    def surface_evol(self, axis: str, delta: float, run: bool = True) -> Optional[SurfaceEvol]:
        """
        Compute or get the SurfaceEvol for specific parameters

        This is a non-blocking method. It will return the SurfaceEvol
        object without waiting. This object may not have data right away
        if computation is still in progress. Data will be filled
        asynchronously once computation is finished.
        State of computation can be monitored with the is_ready flag,
        or waited upon with the wait() method.

        Computation will be launched only on first call of this method
        with a specific set of parameters.
        Subsequent calls with the same parameters will not relaunch it.

        Args:
            axis: For which axis the surface evol should be computed
            delta: Increment of the abscissa in meters
            run: When False, the post-processing will not be computed and None will be
                returned if it does not exist yet.

        Returns:
            A SurfaceEvol allowing to access the values.
            `None` if `run` is `False` and the post-processing does not exist.
        """
        if axis not in ["x", "y", "z"]:
            raise TypeError("axis must be x, y or z")
        if not isinstance(delta, numbers.Number) or not (delta > 0):
            raise TypeError(f"delta must be a positive number (got: {delta})")
        return self._get_or_run(SurfaceEvol, {"axis": axis, "delta": delta}, run)

    def slice(
        self, axis: str, coordinate: float, format: str = "png", run: bool = True
    ) -> Optional[Slice]:
        """
        Compute or get a Slice for specific plane parameters

        This is a non-blocking method. It will return the Slice
        object without waiting. This object may not have data right away
        if computation is still in progress. Data will be filled
        asynchronously once computation is finished.
        State of computation can be monitored with the is_ready flag,
        or waited upon with the wait() method.

        Computation will be launched only on first call of this method
        with a specific set of parameters.
        Subsequent calls with the same parameters will not relaunch it.

        The slice is in the NPZ format.

        Args:
            axis: The axis to slice
            coordinate: Coordinate along the given axis to slice at
            format: The format of the output, "png" or "vtp", defaults to "png"
            run: When False, the post-processing will not be computed and None will be
                returned if it does not exist yet.

        Returns:
            A Slice object allowing to download the binary data.
            `None` if `run` is `False` and the post-processing does not exist.

        Example:
            Make a slice and open it in a new window using the pillow library

            .. code-block:: python

                import ansys.simai.core
                from PIL import Image

                simai = ansys.simai.core.from_config()
                prediction = simai.predictions.list()[0]
                slice_data = prediction.post.slice("x", 50).data.in_memory()
                slice = Image.open(slice_data)
                slice.show()

        """
        if axis not in ["x", "y", "z"]:
            raise InvalidArguments(f"{axis} is not a valid axis, should be one of x, y, z")
        if format not in ["png", "vtp"]:
            raise InvalidArguments(f"{format} is not a valid format, should be one of png, vtp")
        plane = convert_axis_and_coordinate_to_plane_eq_coeffs(axis, coordinate)
        return self._get_or_run(Slice, {"plane": plane, "output_format": format}, run)

    def surface_vtp(self, run: bool = True) -> Optional[SurfaceVTP]:
        """
        Compute or get the result of the prediction's surface in VTP format.

        This is a non-blocking method. It will return the PostProcessingVTP
        object without waiting. This object may not have data right away
        if computation is still in progress. Data will be filled
        asynchronously once computation is finished.
        State of computation can be monitored with the is_ready flag,
        or waited upon with the wait() method.

        Computation will be launched only on first call of this method.
        Subsequent calls will not relaunch it.

        Args:
            run: When False, the post-processing will not be computed and None will be
                returned if it does not exist yet.

        Returns:
            A :class:`SurfaceVTP` object allowing to download the binary data.
            `None` if `run` is `False` and the post-processing does not exist.

        Examples:
            Run and download a surface VTP

            .. code-block:: python

                import ansys.simai.core

                simai = ansys.simai.core.from_config()
                prediction = simai.predictions.list()[0]
                surface_vtp = prediction.post.surface_vtp().data.download("/tmp/simai.vtp")


            Run a surface VTP and open a plot using pyvista

            .. code-block:: python

                import ansys.simai.core
                import pyvista
                import tempfile

                simai = ansys.simai.core.from_config()
                prediction = simai.predictions.list()[0]
                surface_vtp_data = prediction.post.surface_vtp().data
                # I don't want to save the file locally but pyvista doesn't read file-objects
                # Using temporary file as a workaround but a real path can be used instead
                with tempfile.NamedTemporaryFile(suffix=".vtp") as temp_vtp_file:
                    surface_vtp_data.download(temp_vtp_file.name)
                    surface_vtp = pyvista.read(temp_vtp_file.name)
                    surface_vtp.plot()
        """
        return self._get_or_run(SurfaceVTP, {}, run)

    def volume_vtu(self, run: bool = True) -> Optional[VolumeVTU]:
        """
        Compute or get the result of the prediction's volume in VTU format.

        This is a non-blocking method. It will return the PostProcessingVTU
        object without waiting. This object may not have data right away
        if computation is still in progress. Data will be filled
        asynchronously once computation is finished.
        State of computation can be monitored with the is_ready flag,
        or waited upon with the wait() method.

        Computation will be launched only on first call of this method.
        Subsequent calls will not relaunch it.

        Args:
            run: When False, the post-processing will not be computed and None will be
                returned if it does not exist yet.

        Returns:
            A :class:`VolumeVTU` object allowing to download the binary data.

        Examples:
            Run and download a volume VTU

            .. code-block:: python

                import ansys.simai.core

                simai = ansys.simai.core.from_config()
                prediction = simai.predictions.list()[0]
                volume_vtu = prediction.post.volume_vtu().data.download("/tmp/simai.vtu")


            Run a volume VTU and open a plot using pyvista

            .. code-block:: python

                import ansys.simai.core
                import pyvista
                import tempfile

                simai = ansys.simai.core.from_config()
                prediction = simai.predictions.list()[0]
                volume_vtu_data = prediction.post.volume_vtu().data
                # I don't want to save the file locally but pyvista doesn't read file-objects
                # Using temporary file as a workaround but a real path can be used instead
                with tempfile.NamedTemporaryFile(suffix=".vtu") as temp_vtu_file:
                    volume_vtu_data.download(temp_vtu_file.name)
                    volume_vtu = pyvista.read(temp_vtu_file.name)
                    volume_vtu.plot()
        """
        return self._get_or_run(VolumeVTU, {}, run)

    @property
    def _local_post_processings(self):
        """
        Returns the post processings launched by the local session,
        thus which will be waited upon.
        """
        local_post_processings = []
        for pp_by_type in self._post_processings.values():
            local_post_processings.extend(pp_by_type.values())
        return local_post_processings

    def _delete_local_post_processing(self, post_processing: PostProcessing):
        params = post_processing.fields.get("location", {})
        params_frozen = frozenset(params.items())
        del self._post_processings[post_processing.__class__][params_frozen]

    def _get_or_run(
        self, pp_class: Type[PostProcessing], params: Dict[str, Any], run: bool
    ) -> Optional["PostProcessing"]:
        """
        Nonblocking method. Runs (if not already ran/running) the post-processing of given type,
        with given parameters or gets it if the run arg is False.
        If already existing, will return the existing PostProcessing
        """
        # FIXME frozenset(params.items()) works as long as there are no
        # collision between params (axis and delta for surface evol, param for slice)
        # but will be broken if a new type of post-processings can have
        # 2 params with the same value.
        params_frozen = frozenset(params.items())
        # If post-processing of this type and with those params already exist locally, return it
        if pp_class in self._post_processings and params_frozen in self._post_processings[pp_class]:
            return self._post_processings[pp_class][params_frozen]
        if run:
            api_response = self._client._api.run_post_processing(
                self.prediction.id, pp_class._api_name(), params
            )
        else:
            api_response = self._client._api.get_post_processings_for_prediction(
                self.prediction.id, pp_class._api_name(), params
            )
            # The API is supposed to return a list of one element (because we filtered for the specific params).
            # Check that it's the case and extract that element from the list.
            if len(api_response) == 0:
                return None
            elif len(api_response) > 1:
                raise InvalidServerStateError(
                    cleandoc(
                        f"""
                        Multiple post-processings where found when only one should have been.
                        Please contact us at support-simai@ansys.com with that message to help us fix this issue.
                        {[pp['id'] for pp in api_response]}
                        """
                    )
                )
            else:
                api_response = api_response[0]

        post_processing = self._client._post_processing_directory._model_from(
            data=api_response, pp_class=pp_class, prediction=self.prediction
        )
        if pp_class not in self._post_processings:
            self._post_processings[pp_class] = {}
        self._post_processings[pp_class][params_frozen] = post_processing
        for location, warning_message in post_processing.fields.get("warnings", {}).items():
            logger.warning(f"{location}: {warning_message}")
        return post_processing


class PostProcessingDirectory(Directory[PostProcessing]):
    _data_model = PostProcessing

    @classmethod
    def _data_model_for_type_name(cls, pp_type_name: str) -> Optional[Type[PostProcessing]]:
        return getattr(sys.modules[__name__], pp_type_name, None)

    def _model_from(
        self,
        data: dict,
        pp_class: Type[PostProcessing] = None,
        prediction: "Prediction" = None,
    ) -> PostProcessing:
        if pp_class is not None:
            constructor = pp_class
        else:
            constructor = self._data_model_for_type_name(data["type"])
            if not constructor:
                raise ValueError(f"""Received unknown post-processing type {data['type']}.""")
        post_processing = super()._model_from(data, data_model=constructor)
        post_processing._prediction = prediction
        return post_processing

    @property
    def info(self) -> List[Dict[str, Any]]:
        """
        Return a dictionary containing information about the available post-processings and their parameters.

        Example:
            .. code-block:: python

                from pprint import pprint
                import ansys.simai.core

                simai = ansys.simai.core.from_config()
                post_processing_info = simai.post_processings.info
                pprint(post_processing_info)
        """
        return self._client.current_workspace.model.post_processings

    def get(self, id: str) -> PostProcessing:
        """
        Get a specific post-processing object from the server.

        Args:
            id: The id of the post-processing to get

        Returns:
            The :py:class:`PostProcessing` with the given id if it exists

        Raises:
            NotFoundError: No post-processing with the given id exists
        """
        data = self._client._api.get_post_processing_result(id)
        return self._model_from(data)

    def list(
        self,
        post_processing_type: Optional[Type[PostProcessing]] = None,
        prediction_id: Optional[str] = None,
    ) -> List[PostProcessing]:
        """
        List the post-processings in the current workspace or associated to a prediction.

        Optionally you choose to list only post-processings of a specific type.
        For the name of the available post-processings, please refer to :ref:`available_pp`
        Note that the case must be respected.

        Args:
            post_processing_type: The type of post-processing to list
            prediction_id: The id of a prediction, if given will only return post-processings associated to it

        Raises:
            NotFoundError: The post-processing type and/or the prediction id are incorrect.

        Example:
            .. code-block:: python

                import ansys.simai.core

                simai = ansys.simai.core_from_config()
                prediction = simai.predictions.list()[0]
                post_processings = simai.post_processings.list(
                    ansys.simai.core.SurfaceEvol, prediction.id
                )
        """
        pp_type_str = post_processing_type._api_name() if post_processing_type else None
        if not prediction_id:
            post_processings = self._client._api.get_post_processings_in_workspace(
                self._client.current_workspace.id, pp_type_str
            )
        else:
            post_processings = self._client._api.get_post_processings_for_prediction(
                prediction_id, pp_type_str
            )
        return list(map(self._model_from, post_processings))

    def run(
        self,
        post_processing_type: Union[str, Type[PostProcessing]],
        prediction_id: str,
        parameters: Optional[Dict[str, Any]] = None,
        **kwargs,
    ) -> PostProcessing:
        """
        Run a post-processing on a prediction.

        For the name and the parameters expected by the post-processings,
        please refer to :ref:`available_pp` and :ref`pp_methods` sections.
        Note that the case of the class names must be respected.

        Args:
            prediction_id: The id of the prediction for which to run the post-processing.
            post_processing_type: The type of post-processing to run, as a string or as the class itself
            parameters: The parameters to apply to the post-processing, if needed. Alternatively, parameters can be passed as kwargs.

        Examples:
            .. code-block:: python

                import ansys.simai.core

                simai = ansys.simai.core_from_config()
                prediction = simai.predictions.list()[0]
                simai.post_processings.run(
                    ansys.simai.core.Slice, prediction.id, {"axis": "x", coordinate: 50}
                )

            Using kwargs:

            .. code-block:: python

                simai.post_processings.run(
                    ansys.simai.core.Slice, prediction.id, axis="x", coordinate=50
                )
        """
        if isinstance(post_processing_type, str):
            post_processing_type = getattr(
                sys.modules[__name__], post_processing_type, post_processing_type
            )

        if isinstance(post_processing_type, type) and issubclass(
            post_processing_type, PostProcessing
        ):
            pp_class = post_processing_type
        else:
            raise InvalidArguments(
                cleandoc(
                    f""""{post_processing_type}" is not a valid post-processing type.
                    You can find the available post-processings by accessing the .post_processings.info attribute of your SimAIClient
                    """
                )
            )
        prediction = self._client.predictions.get(prediction_id)
        if not parameters:
            parameters = {}
        parameters.update(**kwargs)
        return prediction.post._get_or_run(pp_class, parameters, True)

    def delete(self, id):
        """
        Delete a post-processing by id.

        Args:
            id: The id of the post-processing to delete
        """
        # FIXME?: This won't update the post_processings of the prediction's PredictionPostProcessings if any.
        # Doing so would require an extra call to get the prediction info and I'm not sure there's really a point
        self._client._api.delete_post_processing(id)
